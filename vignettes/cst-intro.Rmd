---
title: "Getting started with the Climate Scenarios Toolbox"
author: "Travis Williams and Max Joseph"
date: "2020-03-25"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{cst}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---



This vignette provides a walk-through of a common use case of the cst package:
understanding future climate scenarios for a region of interest. 
We'll use Wind Cave National Park, located in South Dakota, USA as a case study.

### What you'll learn

This vignette will show you how to: 

- Access climate data for a spatial region of interest
- Produce a data.frame containing climate data
- Visualize historical and future data
- Generate and analyze new climate variables

### What you'll need

To get the most out of this vignette, we assume you have: 

- At least 500 MB of disk space
- Some familiarity with ggplot2
- Some familiarity with dplyr (e.g., `filter()`, `group_by()`, and `summarize()`)

## About the data

Global Circulation Models (GCMs) provide estimates of historical and future 
climate conditions. 
The complexity of the climate system has lead to a large number GCMs and it is
common practice to examine outputs from many different models, treating each as 
one plausible future.

Most GCMs are spatially coarse (often 1 degree), but downscaling provides finer
scale estimates. The cst package uses one downscaled climate model called MACA 
(Multivariate Adaptive Climate Analog) Version 2 
([details here](http://www.climatologylab.org/maca.html)).

### Acquiring and subsetting data within National Park Service boundaries

This package was originally written with the National Park Service in mind, so
it has the option to use the name of any park within the NPS. Use the 
`cstdata()` function to specify a range of years, a set of models, a set of 
parameters, and a set of representative concentration pathways to return. 
Leaving these arguments empty will results in a download of all available data 
for that location.



```r
library(cst)
library(tibble)
library(ggplot2)
library(tidyr)
library(lubridate)
library(ggrepel)
library(dplyr)
library(reticulate)
```

If you haven't already installed the python dependencies for the package using
conda, first make sure you have conda installed 
([see instructions here](https://docs.conda.io/en/latest/miniconda.html)), then
you can install the python dependencies with: 


```r
cst::install_py_deps()
use_condaenv("cst")
```





```r
# choose a project directory to store data
proj_dir <- "~" 

# download data
file_refs <- cstdata(park = "Wind Cave National Park",
                     years = c(1980, 2040),
                     local_dir = proj_dir,
                     parameters = c("tasmin", "tasmax", "uas", "vas"),
                     ncores = parallel::detectCores())
#> [1] "Retrieving area of interest boundaries..."
#> [1] "Building area of interest grid..."
#> [1] "Retrieving climate data for wind_cave_national_park"
#> [1] "Saving local files to /home/mjoseph/wind_cave_national_park"
```

The output of `cstdata` is a data.frame, where each row corresponds to one file:


```r
glimpse(file_refs)
#> Observations: 160
#> Variables: 13
#> $ local_file       <chr> "tasmin_wind_cave_national_park_bcc-csm1-1_r1i1p1_rcâ€¦
#> $ local_path       <chr> "/home/mjoseph/wind_cave_national_park/tasmin_wind_câ€¦
#> $ model            <chr> "bcc-csm1-1", "bcc-csm1-1", "bcc-csm1-1", "bcc-csm1-â€¦
#> $ parameter        <chr> "tasmin", "tasmin", "tasmax", "tasmax", "uas", "uas"â€¦
#> $ rcp              <chr> "rcp45", "rcp85", "rcp45", "rcp85", "rcp45", "rcp85"â€¦
#> $ ensemble         <chr> "r1i1p1", "r1i1p1", "r1i1p1", "r1i1p1", "r1i1p1", "râ€¦
#> $ year1            <dbl> 1980, 1980, 1980, 1980, 1980, 1980, 1980, 1980, 1980â€¦
#> $ year2            <dbl> 2040, 2040, 2040, 2040, 2040, 2040, 2040, 2040, 2040â€¦
#> $ area_name        <chr> "wind_cave_national_park", "wind_cave_national_park"â€¦
#> $ units            <chr> "K", "K", "K", "K", "m s-1", "m s-1", "m s-1", "m s-â€¦
#> $ full_varname     <chr> "Minimum Temperature", "Minimum Temperature", "Maximâ€¦
#> $ internal_varname <chr> "air_temperature", "air_temperature", "air_temperatuâ€¦
#> $ parameter_long   <chr> "air_temperature", "air_temperature", "air_temperatuâ€¦
```

We can generate a data.frame of daily climate values averaged over the study 
region using the `cst_df()` function:


```r
df <- cst_df(file_refs, ncores = parallel::detectCores())
#> Computing spatial averages...
#> Generating climate data.frame...
```

Now, we have a tibble where each row represents a day by model by scenario 
combination, where the climate parameters of interest are represented as 
columns :


```r
glimpse(df)
#> Observations: 891,240
#> Variables: 9
#> $ rcp       <chr> "rcp45", "rcp85", "rcp45", "rcp85", "rcp45", "rcp85", "rcp4â€¦
#> $ date      <date> 1980-01-01, 1980-01-01, 1980-01-01, 1980-01-01, 1980-01-01â€¦
#> $ model     <chr> "bcc-csm1-1", "bcc-csm1-1", "bcc-csm1-1-m", "bcc-csm1-1-m",â€¦
#> $ ensemble  <chr> "r1i1p1", "r1i1p1", "r1i1p1", "r1i1p1", "r1i1p1", "r1i1p1",â€¦
#> $ area_name <chr> "wind_cave_national_park", "wind_cave_national_park", "windâ€¦
#> $ tasmin    <dbl> 268.6556, 268.6556, 249.5089, 249.5089, 267.4565, 267.4565,â€¦
#> $ tasmax    <dbl> 280.0941, 280.0941, 258.7186, 258.7186, 279.6128, 279.6128,â€¦
#> $ uas       <dbl> 3.0490896, 3.0490896, -1.6518571, -1.6518571, 2.6976433, 2.â€¦
#> $ vas       <dbl> 1.4561018, 1.4561018, -1.7092865, -1.7092865, -2.1272987, -â€¦
```

We can work with this data frame to do some basic visualizations, like time 
series for a particular parameter. 
For example, we can use the `filter()` function from dplyr to focus on specific
date ranges and specific emissions scenarios. 


```r
df %>%
  filter(date > Sys.Date(), date < Sys.Date() + 365 * 5, # next 5 years
         rcp == "rcp85") %>%
  ggplot(aes(date, tasmax, group = model)) + 
  geom_line(alpha = .2) + 
  xlab("Time") + 
  ylab("Max. air temperature (K)")
```

<img src="./vpd-timeseries-1.png" title="plot of chunk vpd-timeseries" alt="plot of chunk vpd-timeseries" width="100%" />

### Computing new daily climate variables

Now that we have all of the climate parameters for our study region, we can
compute functions of those variables. 
For example, it is common to compute the midpoint of the maximum and minimum 
daily temperature, which we can do using the `mutate` function: 


```r
df <- df %>%
  mutate(tasmid = (tasmax + tasmin) / 2)
```

Now we have a new column called `tasmid` that is the midpoint of the maximum
and minumum daily temperature!

Wind speed provides another example of a derived parameter that can be computed 
for each day. 
By default, we have two wind-related parameters: the eastward wind component
(called `uas`) and the northward wind component (called `vas`), both in units of 
meters per second (you can get this information from `cst::argument_reference`). 
Wind speed can be computed from `vas` and `uas` using the Pythagorean theorem: 

$\text{Wind speed} = \sqrt{v_{as}^2 + u_{as}^2}.$

In code: 


```r
df <- df %>%
  mutate(wind_speed = sqrt(vas^2 + uas^2))
```

### Computing new climate variable summaries

Sometimes, there are new climate variables that summarize daily data. 
For example, you may want to compute: 

- Last Day of Frost (i.e., last day in spring when min. air temp. < 0 C)
- First Day of Frost (i.e., first day in fall when min. air temp. < 0 C)
- Number of days above or below some threshold (e.g., days with max. air temperature over 40 C, or days with > 1mm of precipitation)
- Growing season length (# days with air temperature > 0 C)

All of these quantities summarize daily data, and require some aggregation time interval which in many cases will be one year. 
As an example, we will compute the growing season length for Wind Cave National Park across all models and emissions scenarios. 
To do this, we first need to define a new column for year, which we will use as a grouping variable: 


```r
df <- df %>%
  mutate(year = year(date))
```

Now, we want to compute growing season length for each year, model, emissions scenario combination. 


```r
growing_seasons <- df %>%
  group_by(rcp, model, year, ensemble) %>%
  summarize(season_length = sum(tasmid > 273.15)) %>%
  ungroup
```

Notice that we used our derived temperature midpoint column `tasmid`, and computed the total (`sum()`) number of days for each group where the temperature midpoint was greater than 0 C (or, 273.15 Kelvin, which are the units of the temperature data).


```r
growing_seasons
#> # A tibble: 2,440 x 5
#>    rcp   model       year ensemble season_length
#>    <chr> <chr>      <dbl> <chr>            <int>
#>  1 rcp45 bcc-csm1-1  1980 r1i1p1             284
#>  2 rcp45 bcc-csm1-1  1981 r1i1p1             299
#>  3 rcp45 bcc-csm1-1  1982 r1i1p1             284
#>  4 rcp45 bcc-csm1-1  1983 r1i1p1             272
#>  5 rcp45 bcc-csm1-1  1984 r1i1p1             295
#>  6 rcp45 bcc-csm1-1  1985 r1i1p1             283
#>  7 rcp45 bcc-csm1-1  1986 r1i1p1             285
#>  8 rcp45 bcc-csm1-1  1987 r1i1p1             281
#>  9 rcp45 bcc-csm1-1  1988 r1i1p1             279
#> 10 rcp45 bcc-csm1-1  1989 r1i1p1             272
#> # â€¦ with 2,430 more rows
```

Let's visualize the growing season over time for each model and emission scenario:


```r
growing_seasons %>%
  ggplot(aes(year, season_length, color = rcp, group = model)) + 
  geom_line(alpha = .3) + 
  facet_wrap(~rcp, ncol = 1) + 
  xlab("Year") + 
  ylab("Growing season length (days)") + 
  scale_color_manual(values = c("dodgerblue", "red")) + 
  theme(legend.position = "none")
```

<img src="./plot-grow-season-1.png" title="plot of chunk plot-grow-season" alt="plot of chunk plot-grow-season" width="100%" />


## Comparing climate in two time periods

Use the file reference object that is returned from cst as an input to
`compare_periods` to compare climate between a reference and target period. You
may specify the function with which to aggregate your chosen variable as well
as the yearly time period months of the year to include in this calculation.


```r
comps <- compare_periods(df,
                         var1 = "tasmin",
                         var2 = "tasmax",
                         agg_fun = "mean",
                         target_period = c(2020, 2040),
                         reference_period = c(1980, 2000),
                         months1 = 5:8,
                         months2 = 5:8,
                         scenarios = c("rcp45", "rcp85"))
```

This provides a data frame that can be used to compare the values in the target
and reference period.


```r
glimpse(comps)
#> Observations: 80
#> Variables: 7
#> Groups: rcp [2]
#> $ model           <chr> "bcc-csm1-1", "bcc-csm1-1-m", "BNU-ESM", "CanESM2", "â€¦
#> $ rcp             <chr> "rcp45", "rcp45", "rcp45", "rcp45", "rcp45", "rcp45",â€¦
#> $ variable        <chr> "tasmin", "tasmin", "tasmin", "tasmin", "tasmin", "taâ€¦
#> $ units           <chr> "K", "K", "K", "K", "K", "K", "K", "K", "K", "K", "K"â€¦
#> $ value_reference <dbl> 284.0221, 283.8716, 284.1512, 283.6515, 283.9051, 283â€¦
#> $ value_target    <dbl> 284.9774, 285.0160, 285.6242, 286.2288, 285.4229, 285â€¦
#> $ difference      <dbl> 0.9553126, 1.1443937, 1.4730053, 2.5772584, 1.5177512â€¦
```

One useful plot shows the difference in the two variables between reference and
target periods:


```r
comps %>%
  dplyr::select(parameter, rcp, model, year1, year2, diff_summary) %>%
  pivot_wider(names_from = parameter, values_from = diff_summary) %>%
  ggplot(aes(tasmin, tasmax, color = rcp)) + 
  geom_point() + 
  geom_hline(yintercept = 0, alpha = .2) + 
  geom_vline(xintercept = 0, alpha = .2) +
  geom_text_repel(aes(label = model), segment.size = .3, size = 3) + 
  xlab("Difference in min. temperature (C)") + 
  ylab("Difference in max. temperature (C)") + 
  scale_color_manual(values = c("dodgerblue", "red"))
#> Error: Can't subset columns that don't exist.
#> [31mx[39m The column `parameter` doesn't exist.
```

So, nearly all model runs indicate warming, but the amount of warming varies by 
model and emissions scenario. 

## Finding out which models and parameters are available

The cst package includes a reference object that can tell you what models, 
scenarios, and climate variables are available. 
You can use the reference object within to see the
available argument options for the `cstdata()` function: `models`, `parameters`,
and `scenarios` (as representative concentration pathways).
The `labels` field will spell out the specific meaning of each parameter, the
`variables` field shows the internal variable name of parameters in the data
sets  themselves, and the `units` field shows the measurement unit of each
variable.


```r
references <- cst::argument_reference
```

Here are the GCMs (the models):


```r
references$models
#>  [1] "bcc-csm1-1"     "bcc-csm1-1-m"   "BNU-ESM"        "CanESM2"       
#>  [5] "CCSM4"          "CNRM-CM5"       "CSIRO-Mk3-6-0"  "GFDL-ESM2M"    
#>  [9] "GFDL-ESM2G"     "HadGEM2-ES365"  "HadGEM2-CC365"  "inmcm4"        
#> [13] "IPSL-CM5A-LR"   "IPSL-CM5A-MR"   "IPSL-CM5B-LR"   "MIROC5"        
#> [17] "MIROC-ESM"      "MIROC-ESM-CHEM" "MRI-CGCM3"      "NorESM1-M"
```

Here are the emissions scenarios: 


```r
references$scenarios
#> [1] "rcp45" "rcp85"
```

And here are the climate parameters


```r
references$parameters
#>  [1] "tasmin" "tasmax" "rhsmin" "rhsmax" "pr"     "rsds"   "uas"    "vas"   
#>  [9] "huss"   "vpd"
```

Not every model has the same set of parameters available, and the
`get_args` method lists model-specific information. 


```r
references$get_args("CCSM4")
#> $parameters
#> [1] "tasmin" "tasmax" "pr"     "rsds"   "uas"    "vas"    "huss"  
#> 
#> $scenarios
#> [1] "rcp45" "rcp85"
#> 
#> $ensemble
#> [1] "r6i1p1"
```


## Why write the cst package?

Because the amount of data generated by downscaled GCMs can be quite large
(e.g., daily data at a few km spatial resolution), the Climate
Scenarios Toolbox was developed to help users quickly download smaller subsets. 

Data is acquired from the [Northwest Knowledge Server of the University of
Idaho](http://thredds.northwestknowledge.net:8080/thredds/reacch_climate_CMIP5_macav2_catalog2.html). 
